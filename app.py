import matplotlib.pyplot as plt 
import numpy as np
from flask import Flask, request, jsonify
import numpy as np
import io
import base64
from flask_cors import CORS
from flask_compress import Compress

app = Flask(__name__)
CORS(app)
Compress(app)

@app.route('/solar-battery-calculation', methods=['POST'])
def calculate_solar_baatery():
    data = request.json
    Total_energy_consumption = data.get('Total_energy_consumption')

    if not Total_energy_consumption:
        return jsonify({"error": "Total_energy_consumption is required"}), 400

    daily_solar_insolation = 5.02 # Daily solar insolation in [KWh/m^2/day]
    one_hour_outage_solar_insolation = 4.6 # Solar insolation during one hour of outage [KWh/m^2]
    two_hour_outage_solar_insolation = 4.2 # Solar insolation during two hours of outage [KWh/m^2]
    three_hour_outage_solar_insolation = 3.8 # Solar insolation during three hours of outage [KWh/m^2]


    local_load = Total_energy_consumption / 24 # Local load [kW]

    battery_nominal_voltage = 12 # Rated battery output voltage [V]

    # Dividing the total energy  into day time and night time part 

    day_time_energy = Total_energy_consumption*(7.03/13.01)
    night_time_energy = Total_energy_consumption*(1 - 7.03/13.01)

    # Calculating PV sizing 

    #Efficiency of different components
    n_module = 0.97 # Efficiency of the module
    n_temperature = 0.89 # Efficiency of module due to high temperature
    n_dust = 0.95 # Efficiency of module due to dust
    n_inverter = 0.9 # Efficiency of the inverter
    n_dcdc = 0.95 # Efficiency of the DC-DC converter
    n_charging = 0.9 # Efficiency of the battery charging
    n_discharging = 0.9 # Efficiency of
    n_battery_roundtrip = n_charging*n_discharging # Efficiency of the battery
    battery_dod = 0.8 # Depth of discharge of the battery

    n_panel = n_module*n_temperature*n_dust # System efficiency of the PV system
    n_panel = 1

    # solar panel sizing

    pv_energy_gen= (day_time_energy/(n_panel*n_inverter*n_dcdc)) + (night_time_energy/(n_panel*n_inverter*n_dcdc*n_battery_roundtrip)) # Energy generated by the PV system
    pv_peak_power = pv_energy_gen/daily_solar_insolation # Peak Power generated by the PV system


    # Calculating the battery sizing

    # Battery energy calculation
    #The battery is  designed to power it for one full night 
    battery_energy = night_time_energy/(n_panel*n_inverter*n_dcdc*n_battery_roundtrip*battery_dod) # Max Energy stored in the battery [kwh]

    battery_capacity = battery_energy/(battery_nominal_voltage)  # Max battery capacity that is needed[kAh]

    # inverter Sizing 
    inverter_rating = pv_peak_power * 1.25  # Size of the inverter [kVA]

    # DC-DC converter sizing
    dcdc_sizing = inverter_rating


    # Economic analysis 

    annual_interest_rate = 0.1 # Annual interest rate

    # Cost of Every component per kW

    # Cost of the solar panel
    pv_cost_perkW = 17846400/594.92 # Cost of the solar panel per kW
    pv_cost = pv_cost_perkW*pv_peak_power # Cost of the solar panel
    x = pv_cost

    # Cost of the battery
    battery_cost_per_kWh = 17720000/(177.2 * 12)  # Cost of the battery per kWh
    battery_cost = battery_cost_per_kWh*battery_energy # Cost of the battery
    w = battery_cost

    # Cost of the inverter
    inverter_cost_per_kVA = 5949200/743.65  # Cost of the inverter per kVA
    inverter_cost = inverter_cost_per_kVA*inverter_rating # Cost of the
    z = inverter_cost

    # Cost of the DC-DC converter
    dcdc_cost_per_kW = 991650/743.65  # Cost of the DC-DC converter
    dcdc_cost = dcdc_cost_per_kW*dcdc_sizing # Cost of the DC-DC converter
    u = dcdc_cost

    # Installation cost of the system

    Installation_cost_dual_mode = 0.1*(pv_cost + battery_cost) # Installation cost of the system
    Installation_cost_on_grid = 0.1*(pv_cost) # Installation cost of the system
    y_on = Installation_cost_on_grid
    y_dual = Installation_cost_dual_mode


    # Annual operation and maintenance cost of the system
    annual_om_cost_dual_mode = 0.03*(pv_cost + battery_cost) # Annual operation and maintenance cost of the system
    annual_om_cost_on_grid = 0.03*(pv_cost) # Annual operation and maintenance cost of the system
    v1_on = annual_om_cost_on_grid
    v1_dual = annual_om_cost_dual_mode

    # cost of additional components of inverter and DC-DC converter
    add_cap_inv_dual_mode_per_kVA = 1984000/743.65 # Cost of additional components of inverter and DC-DC converter per kVA
    add_cap_inv_dual_mode = add_cap_inv_dual_mode_per_kVA*inverter_rating # Cost of additional components of inverter and DC-DC converter
    z2_dual = add_cap_inv_dual_mode

    add_sc_inv_dual_mode_per_kVA = 2976000/743.65 # Cost of additional components of inverter and DC-DC converter per kVA
    add_sc_inv_dual_mode = add_sc_inv_dual_mode_per_kVA*inverter_rating # Cost of additional components of inverter and DC-DC converter
    z1_dual = add_sc_inv_dual_mode

    add_cap_inv_on_grid_per_kVA = 992000/743.65 # Cost of additional components of inverter and DC-DC converter per kVA
    add_cap_inv_on_grid = add_cap_inv_on_grid_per_kVA*inverter_rating # Cost of additional components of inverter and DC-DC converter
    z2_on = add_cap_inv_on_grid

    add_sc_inv_on_grid_per_kVA = 1388000/743.65 # Cost of additional components of inverter and DC-DC converter per kVA
    add_sc_inv_on_grid = add_sc_inv_on_grid_per_kVA*inverter_rating # Cost of additional components of inverter and DC-DC converter
    z1_on = add_sc_inv_on_grid

    # cost of additional components of battery

    add_cap_bat_dual_mode_per_kWh = 119000/(12*177.2) # Cost of additional components of battery per kAh
    add_cap_bat_dual_mode = add_cap_bat_dual_mode_per_kWh*battery_capacity # Cost of additional components of battery
    u2_dual = add_cap_bat_dual_mode

    add_sc_bat_dual_mode_per_kWh = 138800/(12*177.2) # Cost of additional components of battery per kAh
    add_sc_bat_dual_mode = add_sc_bat_dual_mode_per_kWh*battery_capacity # Cost of additional components of battery
    u1_dual = add_sc_bat_dual_mode

    # life times cost of the system

    pv_life = 30 # Life of the solar panel in years
    battry_life = 5 # Life of the battery in years
    sc_life = 10 # Life of the semi conductor in years 
    cap_life = 5 # Life of the capacitor in years

    # Cost calculation for the dual mode system and on grid system

    # Dual mode system
    # Capital cost of the system

    capital_cost_dual_mode = pv_cost + battery_cost + inverter_cost + dcdc_cost + Installation_cost_dual_mode 

    # On-grid system
    # Capital cost of the system

    capital_cost_on_grid = pv_cost + inverter_cost  + Installation_cost_on_grid 

    # Annual cost of the system
    # on-grid system

    annual_cost_on_grid = capital_cost_on_grid*annual_interest_rate + annual_om_cost_on_grid

    # Dual mode system
    annual_cost_dual_mode = capital_cost_dual_mode*annual_interest_rate + annual_om_cost_dual_mode
    
    def plot_to_base64(fig):
        buf = io.BytesIO()
        fig.savefig(buf, format='png', dpi=600, bbox_inches='tight')
        buf.seek(0)
        return base64.b64encode(buf.getvalue()).decode('utf-8')

    # Convert the capital costs to crores
    capital_cost_dual_mode_cr = capital_cost_dual_mode / 1e7
    capital_cost_on_grid_cr = capital_cost_on_grid / 1e7

    # Set the font to Times New Roman for all text in the plot
    plt.rcParams['font.family'] = 'Times New Roman'

    # Create a figure and axis
    fig1, ax1 = plt.subplots()

    # Data for the bar graph
    systems = ['Dual Mode System', 'On-Grid System']
    capital_costs = [capital_cost_on_grid_cr, capital_cost_dual_mode_cr]

    # Plot the data as a bar graph
    x = np.arange(len(systems))  # the label locations
    bar_width = 0.2  # Width of the bars


    bars = ax1.bar(systems, capital_costs, color=['lightblue', 'lightblue'])

    # Annotate each bar with its value in crores, rounded to two decimal places
    for bar in bars:
        height = bar.get_height()
        ax1.text(bar.get_x() + bar.get_width() / 2, height + 0.2, f'{height:.2f} Cr', ha='center', va='bottom')

    # Set labels and title
    ax1.set_ylabel('Capital Cost (INR Cr)')
    ax1.set_title('Capital Cost Comparison of Dual Mode and On-Grid Systems')
    ax1.set_ylim(0, 14)
    
    # Convert plot to base64 string
    capital_cost_plot = plot_to_base64(fig1)

    # Close the figure to free up memory
    plt.close(fig1)

    # cost of Energy generation

    # on-grid system

    # Total Energy generation
    T_on = 365*pv_peak_power*daily_solar_insolation*n_panel*n_inverter # Total Energy generation in a year

    # Cost of Energy generation
    cost_energy_on_grid = annual_cost_on_grid/T_on

    # Dual mode system

    # Total Energy generation
    T_dual = 365*pv_peak_power*daily_solar_insolation*n_panel*n_inverter*n_dcdc # Total Energy generation in a year

    # Cost of Energy generation
    cost_energy_dual_mode = annual_cost_dual_mode/T_dual

    # Annual revenue of the system considering the energy generation at no grid outage scenario

    annual_revenue_on_grid = T_on*8  # Annual revenue of the on-grid system at 8 Rs/kWh
    annual_revenue_dual_mode = T_dual*8  # Annual revenue of the dual mode system at 8 Rs/kWh

    # Considering the outage scenario

    # Only case with of system with local load is considered
    # ON grid system

    # Day grid outage
    # Energy generation during the outage
    T_on_onehour = 365*pv_peak_power*one_hour_outage_solar_insolation*n_panel*n_inverter # Total Energy generation in a year
    T_on_twohour = 365*pv_peak_power*two_hour_outage_solar_insolation*n_panel*n_inverter # Total Energy generation in a year
    T_on_threehour = 365*pv_peak_power*three_hour_outage_solar_insolation*n_panel*n_inverter # Total Energy

    # Cost of Energy generation

    cost_energy_on_grid_onehour = annual_cost_on_grid/T_on_onehour
    cost_energy_on_grid_twohour = annual_cost_on_grid/T_on_twohour
    cost_energy_on_grid_threehour = annual_cost_on_grid/T_on_threehour

    # Night time grid outage
    # Energy generation during the outage
    T_on_night = 365*pv_peak_power*daily_solar_insolation*n_panel*n_inverter # Total Energy generation in a year

    # Cost of Energy generation
    cost_energy_on_grid_night = annual_cost_on_grid/T_on_night # The cost of energy for the case of night time outage will be same irrespective of the duration of the outage

    # Dual mode System 

    # Day time grid outage
    # Energy generation during the outage

    T_dual_zero = 365*((daily_solar_insolation * local_load) + (pv_peak_power - (local_load / (n_dcdc * n_inverter))) * daily_solar_insolation*n_dcdc*n_inverter)  # Total Energy generation in a year

    T_dual_onehour = 365 * ((daily_solar_insolation * local_load) + (pv_peak_power - (local_load / (n_dcdc * n_inverter))) *one_hour_outage_solar_insolation*n_inverter*n_dcdc)  # Total Energy generation in a year
    T_dual_twohour = 365 *((daily_solar_insolation * local_load*n_panel) + (pv_peak_power*n_panel - (local_load / (n_dcdc * n_inverter*n_panel))) * two_hour_outage_solar_insolation*n_inverter*n_dcdc)  # Total Energy generation in a year
    T_dual_threehour = 365 *((daily_solar_insolation * local_load*n_panel) + (pv_peak_power*n_panel - (local_load / (n_dcdc * n_inverter*n_panel))) * three_hour_outage_solar_insolation*n_inverter*n_dcdc)  # Total Energy generation in a year

    # Annual secondary benefits of the system
    # Dual mode system

    AS_one_hour = local_load * 365 * 1 * 29  # Annual secondary benefits of the system, 29 rupees per kWh saved from using the diesel generator
    AS_two_hour = local_load * 365 * 2 * 29  # Annual secondary benefits of the system
    AS_three_hour = local_load * 365 * 3 * 29  # Annual secondary benefits of the system


    #  Cost of Energy generation
    cost_energy_dual_mode_onehour = (annual_cost_dual_mode - AS_one_hour) / T_dual_onehour
    cost_energy_dual_mode_twohour = (annual_cost_dual_mode - AS_two_hour) / T_dual_twohour
    cost_energy_dual_mode_threehour = (annual_cost_dual_mode - AS_three_hour) / T_dual_threehour

    # Dual mode system 
    # Night time grid outage

    # Energy stored in the battery for the night time outage

    #battery_time = (battery_energy * battery_dod * n_inverter * n_dcdc) / local_load  # Time for which the battery can power the load

    # Energy generation during the outage
    # If battery time is less than the outage time, then use this formula
    # In the following format 
    # T_dual_night_onehour = 365 * (local_load *n_panel*( daily_solar_insolation +  n ) + daily_solar_insolation * n_dcdc * n_inverter * ( pv_peak_power*n_panel - (local_load / (n_dcdc * n_inverter *n_panel))))  # Total Energy generation in a year
    # 'n' will be the number of hours of outage

    T_dual_night_onehour = 365 * (local_load*( daily_solar_insolation *n_panel +  1 ) + daily_solar_insolation * n_dcdc * n_inverter * ( pv_peak_power*n_panel - (local_load / (n_dcdc * n_inverter *n_panel))))  # Total Energy generation in a year
    T_dual_night_twohour = 365 * (local_load *n_panel*( daily_solar_insolation +  2 ) + daily_solar_insolation * n_dcdc * n_inverter * ( pv_peak_power *n_panel - (local_load / (n_dcdc * n_inverter *n_panel))))  # Total Energy generation in a year
    T_dual_night_threehour = 365 * (local_load *n_panel*( daily_solar_insolation +  3 ) + daily_solar_insolation * n_dcdc * n_inverter * ( pv_peak_power *n_panel - (local_load / (n_dcdc * n_inverter *n_panel))))  # Total Energy generation in a year

    # The cost of charging the battery for the night time outage 
    # In the following format
    # Annual_battery_cost_onehour = local_load * 365 * n * 8 # Annual secondary spending of the system, 8 rupees per kWh given to grid for buying the energy
    # n will be the number of hours of outage

    Annual_battery_cost_onehour = local_load * 365 * 1 * 8 # Annual secondary spending of the system, 8 rupees per kWh given to grid for buying the energy
    Annual_battery_cost_twohour = local_load * 365 * 2 * 8 # Annual secondary spending of the system
    Annual_battery_cost_threehour = local_load * 365 * 3 * 8 # Annual secondary spending of the system

    # Cost of Energy generation

    cost_energy_dual_mode_night_onehour = (annual_cost_dual_mode + Annual_battery_cost_onehour - AS_one_hour) / T_dual_night_onehour
    cost_energy_dual_mode_night_twohour = (annual_cost_dual_mode + Annual_battery_cost_twohour - AS_two_hour) / T_dual_night_twohour
    cost_energy_dual_mode_night_threehour = (annual_cost_dual_mode + Annual_battery_cost_threehour - AS_three_hour) / T_dual_night_threehour

    

    plt.rcParams['font.family'] = 'Times New Roman'
    # Create a figure and axis
    fig2, ax = plt.subplots()

    # Data for the bar graph
    durations = [0, 1, 2, 3]  # Duration of the daytime outage in hours
    costs = [cost_energy_dual_mode, cost_energy_dual_mode_onehour, cost_energy_dual_mode_twohour, cost_energy_dual_mode_threehour]  # Corresponding costs

    # Plot the data as a bar graph
    bars = ax.bar(durations, costs, color='lightblue', label='Dual mode system')

    # Annotate each bar with its value
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height + 0.02, f'{height:.2f}', ha='center', va='bottom')

    # Set labels and title
    ax.set_xlabel('Duration of the Daytime Outage (hours)')
    ax.set_ylabel('Cost of Energy (Rs/kWh)')
    ax.set_title('Cost of Energy Generation for Different Daytime Outage Scenarios')

    # Set the y-axis limit
    #ax.set_ylim(0, max(costs) + 0.5)  # Adjust this as needed

    # Add a legend
    ax.legend()

    # Display the plot
    daytime_outage_plot = plot_to_base64(fig2)

    plt.close(fig2)

    plt.rcParams['font.family'] = 'Times New Roman'

    # Create a figure and axis
    fig3, ax = plt.subplots()

    # Data for the bar graph
    durations = [0, 1, 2, 3]  # Duration of the nighttime outage in hours
    costs = [cost_energy_dual_mode, cost_energy_dual_mode_night_onehour, cost_energy_dual_mode_night_twohour, cost_energy_dual_mode_night_threehour]  # Corresponding costs

    # Plot the data as a bar graph
    bars = ax.bar(durations, costs, color='lightblue', label='Dual mode system')

    # Annotate each bar with its value
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height + 0.2, f'{height:.2f}', ha='center', va='bottom')

    # Set labels and title
    ax.set_xlabel('Duration of the Nighttime Outage (hours)')
    ax.set_ylabel('Cost of Energy (Rs/kWh)')
    ax.set_title('Cost of Energy Generation for Different Nighttime Outage Scenarios')

    # Set the y-axis limit
    ax.set_ylim(0, max(costs) + 0.5)  # Adjust this as needed

    # Add a legend
    ax.legend()

    # Save the plot as a high-quality image
    nighttime_outage_plot = plot_to_base64(fig3)

    

    

    plt.close(fig3)
    
    # Set the font to Times New Roman for all text in the plot
    plt.rcParams['font.family'] = 'Times New Roman'

    # Create a figure and axis
    fig4, ax = plt.subplots()

    # Data for the bar graph
    durations = [0, 1, 2, 3]  # Duration of the daytime outage in hours
    costs = [cost_energy_on_grid, cost_energy_on_grid_onehour, cost_energy_on_grid_twohour, cost_energy_on_grid_threehour]  # Corresponding costs

    # Plot the data as a bar graph
    bars = ax.bar(durations, costs, color='lightblue', label='On-grid system')

    # Annotate each bar with its value
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height + 0.2, f'{height:.2f}', ha='center', va='bottom')

    # Set labels and title
    ax.set_xlabel('Duration of the Daytime Outage (hours)')
    ax.set_ylabel('Cost of Energy (Rs/kWh)')
    ax.set_title('Cost of Energy Generation for Different Daytime Outage Scenarios')

    # Set the y-axis limit
    ax.set_ylim(0, 6)  # Set this limit according to your data range

    # Add a legend
    ax.legend()

    # Save the plot as a high-quality image
    on_grid_daytime_outage_plot = plot_to_base64(fig4)


    plt.close(fig4)

    # Calculation of Simple Payback Period

    # Dual mode system
    # Simple Payback Period for the dual mode system

    Simple_payback_dual_mode = capital_cost_dual_mode/(annual_revenue_dual_mode - annual_om_cost_dual_mode)

    # On-grid system
    # Simple Payback Period for the on-grid system

    Simple_payback_on_grid = capital_cost_on_grid/(annual_revenue_on_grid - annual_om_cost_on_grid)

    # print(f"The simple payback period for the dual mode system is {Simple_payback_dual_mode:.2f} years")
    # print(f"The simple payback period for the on-grid system is {Simple_payback_on_grid:.2f} years")

    # Plot the bar graph for the simple payback period

    # Convert the simple payback periods to years
    Simple_payback_dual_mode_years = Simple_payback_dual_mode
    Simple_payback_on_grid_years = Simple_payback_on_grid

    # Set the font to Times New Roman for all text in the plot
    plt.rcParams['font.family'] = 'Times New Roman'

    # Create a figure and axis
    fig5, ax = plt.subplots()

    # Data for the bar graph
    systems = [ 'On-Grid System', 'Dual Mode System']
    simple_payback_periods = [Simple_payback_on_grid_years, Simple_payback_dual_mode_years]

    # Plot the data as a bar graph
    x = np.arange(len(systems))  # the label locations
    bar_width = 0.2  # Width of the bars

    bars = ax.bar(systems, simple_payback_periods, color=['lightblue', 'lightblue'])

    # Annotate each bar with its value in years, rounded to two decimal places
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2, height + 0.2, f'{height:.2f} years', ha='center', va='bottom')

    # Set labels and title
    ax.set_ylabel('Simple Payback Period (years)')
    ax.set_title('Simple Payback Period Comparison of Dual Mode and On-Grid Systems')
    ax.set_ylim(0, 8)
    
    # Save the plot as a high-quality image
    simple_payback_plot = plot_to_base64(fig5)


    plt.close(fig5)

    # Calculation of Carbon Emmission

    # Dual mode system
    # Carbon Emmission for the dual mode system

    Carbon_emmission_dual_mode = T_dual*0.8*30/1000

    # On-grid system
    # Carbon Emmission for the on-grid system

    Carbon_emmission_on_grid = T_on*0.8*30/1000

    # print(f"The carbon emmission for the dual mode system is {Carbon_emmission_dual_mode:.2f} Ton")
    # print(f"The carbon emmission for the on-grid system is {Carbon_emmission_on_grid:.2f} Ton")

    # Plot the bar graph for the carbon emmission

    # Convert the carbon emmission to Ton
    Carbon_emmission_dual_mode_Ton = Carbon_emmission_dual_mode/1000
    Carbon_emmission_on_grid_Ton = Carbon_emmission_on_grid/1000

    # Set the font to Times New Roman for all text in the plot
    plt.rcParams['font.family'] = 'Times New Roman'

    # Create a figure and axis

    fig6, ax2 = plt.subplots()

    # Data for the bar graph
    systems = [ 'On-Grid System', 'Dual Mode System']
    carbon_emmission = [Carbon_emmission_on_grid_Ton, Carbon_emmission_dual_mode_Ton]

    # Plot the data as a bar graph
    x = np.arange(len(systems))  # the label locations
    bar_width = 0.2  # Width of the bars

    bars = ax2.bar(systems, carbon_emmission, color=['lightblue', 'lightblue'])

    # Annotate each bar with its value in Ton, rounded to two decimal places
    for bar in bars:
        height = bar.get_height()
        ax2.text(bar.get_x() + bar.get_width() / 2, height + height/1000, f'{height:.2f} Kiloton', ha='center', va='bottom')

    # Set labels and title

    ax2.set_ylabel('Carbon Emission (Kiloton)')
    ax2.set_title('Carbon Emission Comparison of Dual Mode and On-Grid Systems')

    # Save the plot as a high-quality image
    carbon_emission_plot = plot_to_base64(fig6)

    plt.close(fig6)

    response = {
        "Technical Analysis": {
            "Solar Panel Power Rating (kW)": f"{pv_peak_power:.2f}",
            "Battery Energy (kWh)": f"{battery_energy:.2f}",
            "Battery Nominal Voltage (V)": battery_nominal_voltage,
            "Battery Capacity (kAh)": f"{battery_capacity:.2f}",
            "Inverter Rating (kVA)": f"{inverter_rating:.2f}",
            "DC-DC Converter Rating (kW)": f"{dcdc_sizing:.2f}"
        },
        "Economic Analysis": {
            "Solar Panel Cost (Rs)": f"{pv_cost:.2f}",
            "Battery Cost (Rs)": f"{battery_cost:.2f}",
            "Inverter Cost (Rs)": f"{inverter_cost:.2f}",
            "DC-DC Converter Cost (Rs)": f"{dcdc_cost:.2f}",
            "Installation Cost Dual Mode (Rs)": f"{Installation_cost_dual_mode:.2f}",
            "Installation Cost On-Grid (Rs)": f"{Installation_cost_on_grid:.2f}",
            "Annual O&M Cost Dual Mode (Rs)": f"{annual_om_cost_dual_mode:.2f}",
            "Annual O&M Cost On-Grid (Rs)": f"{annual_om_cost_on_grid:.2f}"
        },
        "Capital Cost & Annual Generation": {
            "Capital Cost Dual Mode (Rs)": f"{capital_cost_dual_mode:.2f}",
            "Capital Cost On-Grid (Rs)": f"{capital_cost_on_grid:.2f}",
            "Annual Energy Generation Dual Mode (kWh)": f"{T_dual:.2f}",
            "Annual Energy Generation On-Grid (kWh)": f"{T_on:.2f}",
            "Annual Revenue Dual Mode (Rs)": f"{annual_revenue_dual_mode:,.2f}",
            "Annual Revenue On-Grid (Rs)": f"{annual_revenue_on_grid:,.2f}"
        },
        "Cost of Energy Generation": {
            "Dual Mode Cost (Rs/kWh)": f"{cost_energy_dual_mode:.2f}",
            "Cost for 1 Hour Outage (Rs/kWh)": f"{cost_energy_dual_mode_onehour:.2f}",
            "Cost for 2 Hours Outage (Rs/kWh)": f"{cost_energy_dual_mode_twohour:.2f}",
            "Cost for 3 Hours Outage (Rs/kWh)": f"{cost_energy_dual_mode_threehour:.2f}",
            "Night Time 1 Hour Outage Cost (Rs/kWh)": f"{cost_energy_dual_mode_night_onehour:.2f}",
            "Night Time 2 Hours Outage Cost (Rs/kWh)": f"{cost_energy_dual_mode_night_twohour:.2f}",
            "Night Time 3 Hours Outage Cost (Rs/kWh)": f"{cost_energy_dual_mode_night_threehour:.2f}"
        },
        "On-Grid Cost of Energy Generation": {
            "On-Grid Cost (Rs/kWh)": f"{cost_energy_on_grid:.2f}",
            "Cost for 1 Hour Outage (Rs/kWh)": f"{cost_energy_on_grid_onehour:.2f}",
            "Cost for 2 Hours Outage (Rs/kWh)": f"{cost_energy_on_grid_twohour:.2f}",
            "Cost for 3 Hours Outage (Rs/kWh)": f"{cost_energy_on_grid_threehour:.2f}",
            "Night Time Outage Cost (Rs/kWh)": f"{cost_energy_on_grid_night:.2f}"
        },
        "Simple Payback Period": {
            "Dual Mode System (years)": f"{Simple_payback_dual_mode:.2f}",
            "On-Grid System (years)": f"{Simple_payback_on_grid:.2f}"
        },
        "Carbon Emission": {
            "Dual Mode System (Ton)": f"{Carbon_emmission_dual_mode:.2f}",
            "On-Grid System (Ton)": f"{Carbon_emmission_on_grid:.2f}"
        },
        "Plots": {
            "Capital Cost Comparison": capital_cost_plot,
            "Daytime Outage Cost": daytime_outage_plot,
            "Nighttime Outage Cost": nighttime_outage_plot,
            "On-Grid Daytime Outage Cost": on_grid_daytime_outage_plot,
            "Simple Payback Period Comparison": simple_payback_plot,
            "Carbon Emission Comparison": carbon_emission_plot
        }
    }
    
    # Send the response
    return jsonify(response), 200


@app.route('/solar-panel-degradation', methods=['POST'])
def calculate_solar_panel_degradation():
    data = request.json

    # Parameters
    installed_power = float(data.get('installed_power'))
    panel_age = data.get('panel_age')
    end_of_life = 30  # Typical end of life for solar panels in years

    end_of_life = 30  # Typical end of life for solar panels in years

    # Degradation rates
    initial_degradation_rate = 2  # Annual degradation rate for the first year in percentage
    subsequent_degradation_rate = 0.6  # Annual degradation rate from the second year onwards in percentage

    # Ensure that the panel_age does not exceed end_of_life
    if panel_age > end_of_life:
        print("Error: The current age of the panels cannot exceed their end of life.")
    else:
        # Calculate power degradation at 5-year intervals plus the current age
        years = sorted(list(set([0] + list(range(5, end_of_life + 1, 5)) + [panel_age])))
        power = []

    for year in years:
        if year == 0:
            # Installed power at year 0
            power.append(installed_power)
        elif year == 1:
            # Degraded power after the first year with 1.5% degradation
            power.append(installed_power * (1 - initial_degradation_rate / 100))
        else:
            # Degradation from the second year onwards with 0.5% per year
            total_degradation = initial_degradation_rate + (year - 1) * subsequent_degradation_rate
            power.append(installed_power * (1 - total_degradation / 100))

    # Plotting the results
    x = np.arange(len(years))  # the label locations
    width = 0.6  # Increase the width of the bars

    fig, ax1 = plt.subplots(figsize=(12, 6))

    # Define colors for bars
    colors = ['purple' if year == panel_age else 'lightblue' for year in years]
    
    # Set font properties to Times New Roman
    plt.rcParams['font.family'] = 'serif'
    plt.rcParams['font.serif'] = ['Times New Roman']

    # Plot power output at each interval
    bars = ax1.bar(x, power, width, color=colors, label='Power Output')
    ax1.set_xlabel('Years')
    ax1.set_ylabel('Power Output (W)')
    ax1.set_title('Solar Power Degradation Over Time')
    ax1.set_xticks(x)
    ax1.set_xticklabels(years)
    
    # Remove the grid from the plot
    ax1.grid(False)

    # Add values on top of the bars
    for bar in bars:
        height = bar.get_height()
        ax1.annotate(f'{height:.1f}',
                     xy=(bar.get_x() + bar.get_width() / 2, height),
                     xytext=(0, 3),  # 3 points vertical offset
                     textcoords="offset points",
                     ha='center', va='bottom')

    # Save plot to a bytes buffer
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    image_base64 = base64.b64encode(buf.read()).decode('utf-8')
    buf.close()

    # Clear the figure
    plt.close(fig)

    # Return the image as a response
    return jsonify({        
        "plot_image": image_base64
    })
